{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MMG3320/5320: Advanced Bioinformatics","text":""},{"location":"#teaching-materials","title":"Teaching Materials","text":"<p>This repository contains teaching materials from hbctraining but has been modified to support students enrolled in MMG3320/5320: Advanced Bioinformatics at the University of Vermont. The full citation for this work is provided below. </p>"},{"location":"#installation-requirements","title":"Installation Requirements","text":"<p>All students will be using Vermont Advanced Computing Core - Open OnDemand Website VACC-OOD </p> <p>Link to VACC-OOD</p> <p>https://vacc-ondemand.uvm.edu </p>"},{"location":"#citation","title":"Citation","text":"<p>To cite material from this course in your publications, please use:</p> <p>Jihe Liu, William J. Gammerdinger, Meeta Mistry, Mary E. Piper, &amp; Radhika S. Khetani. (2022, January 6). hbctraining/Intro-to-shell-flipped: Shell and HPC Lessons from HCBC (first release). Zenodo. https://doi.org/10.5281/zenodo.5826091</p> <p>A lot of time and effort went into the preparation of these materials. Citations help us understand the needs of the community, gain recognition for our work, and attract further funding to support our teaching activities. Thank you for citing this material if it helped you in your data analysis.</p> <p>These materials have been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> <p>Some materials used in these lessons were derived from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).  All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</p>"},{"location":"R/whyR/","title":"Why R?","text":"<pre><code>x &lt;- 3\n</code></pre>"},{"location":"R/whyR/#what-is-r","title":"What is R?","text":"<p>R is much more than a programming language, you can think of R as an  environment for statistical computing and graphics, which brings together  a number of features to provide powerful functionality.</p> <p>The R environment combines:</p> <ul> <li>effective handling of big data </li> <li>collection of integrated tools</li> <li>graphical facilities</li> <li>simple and effective programming language</li> </ul>"},{"location":"R/whyR/#why-use-r","title":"Why use R?","text":"<p>R is a powerful, extensible environment. It has a wide range of  statistics and general data analysis and visualization capabilities.</p> <ul> <li>Data handling, wrangling, and storage</li> <li>Wide array of statistical methods and graphical techniques available</li> <li>Easy to install on any platform and use (and it\u2019s free!)</li> <li>Open source with a large and growing community of peers</li> </ul>"},{"location":"ch01/","title":"Overview","text":""},{"location":"ch01/#chapter-1","title":"Chapter 1","text":"<p>This is the first chapter of many</p>"},{"location":"ch01/01_week1_mmg3320/","title":"Learning Objectives for Today's Lesson","text":"<ul> <li>Log into the VACC, a high-performance computing cluster </li> <li>Basics in navigation in CLI </li> <li>Copy data into your home directory </li> <li>List files in a directory</li> </ul>"},{"location":"ch01/01_week1_mmg3320/#introduction-to-command-line","title":"Introduction to Command Line","text":"<p>Command line interface (CLI) and graphical user interface (GUI) are different ways of interacting with a computer's operating system. Most people are familiar with the GUI as it is the default interface for most software. When using a GUI, you see visual representations of files, folders, applications, etc. However, when using the CLI, you will work largely with text representation of files, folders, input, and output.</p> <p> </p>"},{"location":"ch01/01_week1_mmg3320/#what-is-a-shell","title":"What is a shell?","text":"<p>The shell is a program where users can type commands. With the shell, it\u2019s possible to invoke complicated programs like climate modeling software or simple commands that create an empty directory with only one line of code. The most popular Unix shell is Bash (the Bourne Again SHell \u2014 so-called because it\u2019s derived from a shell written by Stephen Bourne).  Using the shell will take some effort and some time to learn. While a GUI presents you with choices to select, CLI choices are not automatically presented to you, so you must learn a few commands like new vocabulary in a language you\u2019re studying. </p>"},{"location":"ch01/01_week1_mmg3320/#benefits-of-using-shell","title":"Benefits of using shell","text":"<p>Working this way gives you access to internal  controls, remote servers, and the ability to  customize workflows (scripts). So it gives you the ability to create new files, edit the contents of those files, delete files, and much more. </p> <p>In addition, the command line is often the easiest way to interact with remote machines and supercomputers. Familiarity with the shell is near essential to run a variety of specialized tools and resources including high-performance computing systems. As clusters and cloud computing systems become more popular for scientific data crunching, being able to interact with the shell is becoming a necessary skill. We can build on the command-line skills covered here to tackle a wide range of scientific questions and computational challenges.</p>"},{"location":"ch01/01_week1_mmg3320/#how-to-access-the-shell","title":"How to access the shell","text":"<p>On a Mac or Linux machine, you can access a shell through a program called \"Terminal\" locally on your laptop. But to make things easier, we will be using terminal on the open source web portal called Vermont Advance Computing Center - Open OnDemand (VACC-OOD). Once on terminal, you will be learning the basics of shell programming available under the Bourne Again Shell (bash).</p>"},{"location":"ch01/01_week1_mmg3320/#working-with-remote-machines-vermont-advance-computing-center-cluster-vacc","title":"Working with Remote Machines: Vermont Advance Computing Center Cluster (VACC)","text":""},{"location":"ch01/01_week1_mmg3320/#why-work-on-the-vacc","title":"Why work on the VACC?","text":"<p>Most data-processing tasks in bioinformatics require more computing power than we have on our workstations. For all bioinformatics projects performed in this course, you will work over a network connection with the VACC. </p> <p>Cluster Basics</p> <p> </p> <p>The image above reflects the many computers that make up a cluster. Each individual computer in the cluster is a lot more powerful than any laptop or desktop computer we are used to working with, and is referred to as a \"node\" (instead of computer). Therefore, a \"cluster\" is a large system consisting of 100s-1000s of nodes. Each node has a designated role, either for logging in or for performing computational analysis/work. A given cluster will usually have a few login nodes and several compute nodes.</p> <p>Common characteristics of a Cluster:</p> <ul> <li>Large memory </li> <li>Storage shared across nodes </li> <li>High speed interconnection network; suitable for high-throughput applications </li> <li>Shared by many users</li> </ul> <p>As of March 2022, the VACC provides three Clusters:</p> <ul> <li>BlackDiamond </li> <li>Bluemoon </li> <li>DeepGreen</li> </ul> <p>We will primarily use the Bluemoon cluster for any downstream analysis.</p> <p> </p> <p>Please note that more information can always be found at the Vermont Advanced Computing Center website.</p>"},{"location":"ch01/01_week1_mmg3320/#vacc-ood-overview","title":"VACC-OOD Overview","text":"<p>Each student has been provided with their own personal VACC account that they can use to access VACC-Open OnDemand (OOD).</p>"},{"location":"ch01/01_week1_mmg3320/#what-is-open-ondemand-ood","title":"What is Open OnDemand (OOD)?","text":"<p>Open OnDemand (OOD) is an open source web portal for high performance computing (HPC) that provides users with an easy-to-use web interface to HPC clusters.</p> <p>Benefits of using OOD:</p> <ol> <li> <p>Web-based, no additional software needs to be installed on your local machine</p> </li> <li> <p>The easiest way to run graphical user interface (GUI) applications remotely on a cluster</p> </li> <li> <p>Typical computing with command-line requires a high learning curve whereas OOD is easy to use and simple to learn</p> </li> </ol> <p>GUI applications offered by VACC-OOD:</p> <ul> <li>Equipped with Terminal: this is used to perform tasks on the command line (shell), both locally and on remote machines.</li> </ul> <p> </p> <ul> <li>RStudio: an integrated development environment for R</li> </ul> <p> </p>"},{"location":"ch01/01_week1_mmg3320/#how-to-log-in-to-vacc-ood-you-should-always-do-this","title":"How to log-in to VACC-OOD (You should always do this!):","text":"<ol> <li> <p>Use the VACC-OOD link to access the site https://vacc-ondemand.uvm.edu</p> </li> <li> <p>Add your uvm netid and password</p> </li> <li> <p>You should be viewing the following dashboard</p> </li> </ol> <p> </p> <ol> <li>To access the Terminal Go to Clusters  and click <code>&gt;_VACC Shell Access</code></li> </ol> <p> </p>"},{"location":"ch01/01_week1_mmg3320/#connecting-to-vacc-with-ssh","title":"Connecting to VACC with SSH","text":"<p>If you already had a VACC account and/or are currently working towards generating and analyzing your own data, you may want to learn to log-in without VACC-OOD.</p> <p>To do so, first open your terminal locally on your computer.</p> <p> </p> <p>Once you open your terminal, your screen should look similar to below: </p> <p> </p> <p>You see the \"$\" symbol?</p> <p>That is where you write the \"commands\" that will be executed by shell (bash in this case) and your computer's kernel.</p> <p>The \"$\" is called the \"command prompt\".</p>"},{"location":"ch01/01_week1_mmg3320/#what-is-ssh","title":"What is SSH?","text":"<p>There are many ways to connect to another machine over a network, but by far the most common is through the secure shell (SSH). We use SSH because its encrypted. This makes it secure to send passwords and edit private data files. </p>"},{"location":"ch01/01_week1_mmg3320/#step-by-step-instructions-to-connect-to-the-login-node-on-vacc","title":"Step-by-step instructions to connect to the login node on VACC:","text":"<ol> <li>Type in the <code>ssh</code> command at the command prompt followed by a space, and then type your username (e.g. uvm net id) plus the address of the cluster <code>@vacc-user1.uvm.edu</code>.</li> </ol> <pre><code>ssh username@vacc-user1.uvm.edu \n</code></pre> <ol> <li>Press the return/enter key and you should receive a prompt for your password. Type in your password and note that the cursor will not move as you type it in! This is normal and know that the computer is receiving and  transmitting your typed password to the remote system, i.e. the VACC cluster.</li> </ol> <ol> <li>If this is the first time you are connecting to the cluster, a warning will pop up and will ask you if you are sure you want to do this; type <code>Yes</code> or <code>Y</code>.</li> </ol> <p>Tip - Syntax for all commands on the command-line interface is the command followed by space and then     optionally a few arguments. </p> <p>Once logged in, you should see a new command prompt:</p> <p> </p>"},{"location":"ch01/01_week1_mmg3320/#using-vacc-ood-off-campus","title":"Using VACC-OOD OFF-campus","text":"<p>To use OFF-campus you will need to VPN first. See (install-cisco-vpn)[https://www.uvm.edu/it/kb/article/install-cisco-vpn/] for more information!</p>"},{"location":"ch01/01_week1_mmg3320/#copying-example-data-folder","title":"Copying example data folder","text":"<p>Now that we are logged-in to the VACC, lets explore terminal. Your screen should look similar to the following:</p> <p> </p> <p>The \"$\" is called the \"command prompt\".</p> <p>The command prompt on VACC will have some characters before the <code>$</code>, something like <code>[username@vacc-user1 ~]</code>, this is telling you your username and the name of the login node you have connected to.</p> <p>The dollar sign is a prompt which shows us that the shell is waiting for input. Moving forward, when typing commands, either from these lessons or from other sources, do not type in the command prompt $, only the command that follows it.</p> <p>The first thing to do is to check if there are any files in the data folder we are currently in. When you log in to a cluster, you will land within a folder designated specifically for your use, and is referred to as your \"home directory\". We will begin by listing the contents of our home directory using a command called <code>ls</code>.</p> <pre><code>ls \n</code></pre> <p>Tip - <code>ls</code> stands for \"list\" and it lists the contents of a directory.  </p> <p>First let's remove this directory from last semester: </p> <pre><code>rm -r unix_lesson\n</code></pre> <p>Now let's bring in a data folder from a different location on the cluster to our home directory by using the <code>cp</code> command. Copy and paste the following command all the way from <code>cp</code> and including the period symbol at the end <code>.</code></p> <pre><code>cp -r /gpfs1/cl/mmg3320/course_materials/tutorials/unit1_unix .\n</code></pre> <p>Let's break this down. 'cp' is the command for copy. This command required you to specify the location of the item you want to copy (/gpfs1/cl/mmg3320/course_materials/tutorials/unit1_unix) and the location of the destination (.); please note the space between the two in the command. The \u201c-r\u201d is an option that modifies the copy command to do something slightly different than usual. The \".\" means \"here\", i.e. the destination location is where you currently are.</p> <p>Now, you should see \"unit1_unix\" show up as the output of <code>ls</code>. This is a folder we should all have in our home directory.</p> <pre><code>ls \n</code></pre>"},{"location":"ch01/01_week1_mmg3320/#listing-contents-of-data-folder","title":"Listing contents of data folder","text":"<p>Let's look at what is inside the folder \"unit1_unix\" and explore this further. We are use to clicking on a folder name to open it, however, now we are forced to change our mindset and open a folder or \"directory\" differently within the shell environment.</p> <p>To look inside the <code>unit1_unix</code> directory, we need to change which directory we are in. To do this we can use the <code>cd</code> command, which stands for \"change directory\".</p> <pre><code>cd unit1_unix\n</code></pre> <p>Notice the change in your command prompt. The \"~\" symbol from before should have been replaced by the string <code>unit1_unix</code>. This means that our <code>cd</code> command ran successfully and we are now in the new directory. Let's see what is in here by listing the contents:</p> <pre><code>ls \n</code></pre> <p>You should see:</p> <pre><code>genomics_data  other  raw_fastq  README.txt  reference_data \n</code></pre> <p>Notice that <code>ls</code> has printed the name of the files and directories in the current directory in alphabetical order, arranged neatly into columns.</p>"},{"location":"ch01/01_week1_mmg3320/#arguments","title":"Arguments","text":"<p>There are five items listed when you run <code>ls</code>, but how do you know if these are files or directories with more items inside?</p> <p>To answer this question, we can modify the default behavior of <code>ls</code> by adding an \"argument\" to get more information.</p> <pre><code>ls -F \n</code></pre> <pre><code>genomics_data/  other/  raw_fastq/  README.txt  reference_data/ \n</code></pre> <p>Anything with a \"/\" after its name is a directory. Things with an asterisk \"*\" after them are programs.  If there are no \"decorations\" after the name, it's a normal text file.</p> <p>Each line of output represents a file or a directory. The directory lines start with <code>d</code>.</p>"},{"location":"ch01/01_week1_mmg3320/#how-to-get-more-information-on-arguments","title":"How to get more information on Arguments","text":"<p>Most commands will take additional arguments that control their behavior. How do we know what arguments are available for a particular command? The most commonly used shell commands have a manual available that can be accessed using the <code>man</code> command. Let's try this command with <code>ls</code>:</p> <pre><code>man ls \n</code></pre> <p>This will open the manual page for <code>ls</code> and you will lose the command prompt. It will bring you to a so-called \"buffer\" page, a page you can navigate with your mouse or if you want to use your keyboard we have listed some basic key strokes:</p> <ul> <li>'spacebar' to go forward * 'b' to go backward * Up or down arrows to go forward or backward, respectively</li> </ul> <p>To get out of the <code>man</code> \"buffer\" page and to be able to type commands again on the command prompt, press the <code>q</code> key!</p>"},{"location":"ch01/01_week1_mmg3320/#class-exercise","title":"Class Exercise","text":"<ul> <li>Use the <code>-l</code> option for the <code>ls</code> command to display more information for each item in the <code>unit1_unix</code> folder. What additional information is provided that you didn't see with the bare <code>ls</code> command?</li> </ul>"},{"location":"ch01/01_week1_mmg3320/#commands","title":"Commands","text":"<pre><code>cd          \n+ Change Directory \n    +   used to move throughout the filesystem of a computer\n\nls          \n+ List \n    +   list the contents of a directory\n\nrm \n+ Remove \n    + used to remove a file \n</code></pre>"},{"location":"ch01/01_week1_mmg3320/#citation","title":"Citation","text":"<p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> <ul> <li>The materials used in this lesson were derived from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/). All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0). * Adapted from the lesson by Tracy Teal. Original contributors: Paul Wilson, Milad Fatenejad, Sasha Wood and Radhika Khetani for Software Carpentry (http://software-carpentry.org/) authors: Sheldon  McKay, Mary Piper, Radhika Khetani, Meeta Mistry, Jihe Liu date posted: September 28, 2020</li> </ul> <p>Other parts of this lesson were derived from: Erin Alison Becker, Anita Sch\u00fcrch, Tracy Teal, Sheldon John McKay, Jessica Elizabeth Mizzi, Fran\u00e7ois Michonneau, et al. (2019, June). datacarpentry/shell-genomics: Data Carpentry: Introduction to the shell for genomics data, June 2019 (Version v2019.06.1). Zenodo. http://doi.org/10.5281/zenodo.3260560</p>"},{"location":"ch01/02_week1_mmg3320/","title":"Navigating the Shell","text":""},{"location":"ch01/02_week1_mmg3320/#learning-objectives-for-todays-lesson","title":"Learning Objectives for Today's Lesson","text":"<ul> <li>Understand the organization of the Filesystem </li> <li>Distinguish between Full versus Relative paths</li> <li>listing, copying, creating, moving and removing data</li> </ul>"},{"location":"ch01/02_week1_mmg3320/#navigating-the-filesystem","title":"Navigating the Filesystem","text":"<p>A filesystem organizes a computer's files and directories into a tree structure. </p> <p> </p> <ul> <li>The first directory in the filesystem is the root directory. It is the parent of all other directories and files in the filesystem. That <code>/</code> or root is the 'top' level.</li> <li>Each parent directory contains child directories and/or files. </li> <li>Each child directory can also contain more files</li> </ul> <p>Note: When you log in to a remote computer you land on one of the branches of that tree, i.e. your pre-designated \"home\" directory that usually has your login name as its name (e.g. <code>/users/username</code>).</p> <p> </p> <p>To navigate the file system with ease we will now introduce the concept of tab completion. </p>"},{"location":"ch01/02_week1_mmg3320/#shortcut-tab-completion","title":"Shortcut: Tab Completion","text":"<p>tab caps lock</p> <p>Typing out file or directory names can waste a lot of time and its easy to make typing mistakes. Instead we should get in the habit of using tab complete as a shortcut. The <code>tab</code> key is located on the left side of your keyboard, right above the <code>caps lock</code> key. When you start typing out the first few characters of a directory name, then hit the <code>tab</code> key, Shell will try to fill in the rest of the directory name. Let's put this into practice now. </p> <p>Navigate into the <code>raw_fastq</code> directory and see what's inside. Remember to use tab!</p> <pre><code>cd raw_fastq/\n</code></pre>"},{"location":"ch01/02_week1_mmg3320/#class-exercise","title":"Class Exercise:","text":"<ul> <li>List the file sizes of raw_fastq/ folder. </li> </ul>"},{"location":"ch01/02_week1_mmg3320/#paths","title":"Paths","text":"<p>Where is <code>raw_fastq</code> folder in relation to our home directory? To answer this, let's learn more about the \"addresses\" of directories, called \"path\" and move around the file system.</p> <p>Let's check to see what directory we currently are in. The command prompt tells us which directory we are in, but it doesn't give information about where the <code>raw_fastq</code> directory is with respect to our \"home\" directory. </p> <p>The command to check our current location is <code>pwd</code>, this command does not take any arguments and it returns the path or address of your present working directory (the folder you are in currently).</p> <pre><code>pwd\n</code></pre> <p> </p> <p>In the output above, each folder is separated from its \"parent\" or \"child\" folder by a \"/\", and the output starts with the root <code>/</code> directory. So, now you are able to determine the location of <code>raw_fastq</code> directory relative to the root directory. </p> <p>But what if you would like to navigate back to your home directory? To do so, one way would be to type <code>cd ~</code> and this will bring you back to your home directory. The \"~\" is an abbreviation for the current user's home folder. </p> <pre><code>cd ~\n</code></pre> <p>After doing this what is your present working directory now?</p> <pre><code>pwd\n</code></pre> <p>It should look something like this: </p> <pre><code>/users/p/d/pdrodrig\n</code></pre> <p>This should display a shorter string of directories starting with root. This is the full address to your home directory, also referred to as \"full path\". </p>"},{"location":"ch01/02_week1_mmg3320/#using-paths-with-commands","title":"Using paths with commands","text":"<p>You can do a lot more with the idea of stringing together parent/child directories. Let's say we want to look at the contents of the <code>raw_fastq</code> folder, but do it from our current directory (the home directory). We can use the list command and follow it up with the path to the folder we want to list!</p> <pre><code>cd\n\nls ~/unit1_unix/reference_data\n</code></pre> <pre><code>chr1.fa  chr1-hg19_genes.gtf\n</code></pre> <p>Remember that these two scripts indicate the same path:</p> <pre><code>/users/p/d/pdrodrig/unit1_unix/reference_data\n\nEQUALS \n\n~/unit1_unix/reference_data\n</code></pre>"},{"location":"ch01/02_week1_mmg3320/#class-exercise_1","title":"Class Exercise:","text":"<ul> <li>Change directories from <code>~</code> (home) to <code>raw_fastq</code> in a single step then print working directory. </li> </ul> <p> Answer <p>cd ~/unit1_unix/raw_fastq</p> </p> <p>Now, what if we want to move back up a level back into the <code>unix_lesson</code> directory?  Type <code>cd unix_lesson</code> and see what happens.</p> <pre><code>unix_lesson/: No such file or directory\n</code></pre> <p>Unfortunately, that won't work because when you say <code>cd unix_lesson</code>, shell is looking for a folder called <code>unix_lesson</code> within your current directory, i.e. <code>raw_fastq</code>.</p> <p>Can you think of an alternative? </p> <ul> <li>You can use the full path to <code>unix_lesson</code></li> <li>You can do cd .. (allows you to move one folder up)</li> </ul> <pre><code>cd .. \n</code></pre>"},{"location":"ch01/02_week1_mmg3320/#file-names","title":"File Names","text":"<p>Probably one of the most frustrating parts of bioinformatics is the lack of consistency with how files are labeled. Files often have obscure names that is only relevant to the researcher, or have names that are very similar to one another. But nonetheless we will persevere! </p> <p>Let's go into the <code>raw_fastq</code>, then type <code>ls Mov10_oe_</code>, followed by pressing the <code>tab</code> key once:</p> <pre><code>cd raw_fastq/\nls Mov10_oe_&lt;tab&gt;\n</code></pre> <p>Notice that nothing happens!!</p> <p>The reason is there are multiple files in the <code>raw_fastq</code> directory that start with <code>Mov10_oe_</code>. As a result, shell does not know which one to fill in. When you hit <code>tab</code> a second time again, the shell will then list all the possible choices.</p> <pre><code>ls Mov10_oe_&lt;tab&gt;&lt;tab&gt;\n\nMov10_oe_1.subset.fq  Mov10_oe_2.subset.fq  Mov10_oe_3.subset.fq\n</code></pre> <p>Now you can select the one you are interested in listed, and enter the number and hit tab again to fill in the complete name of the file.</p> <pre><code>ls Mov10_oe_1&lt;tab&gt;\n</code></pre> <p>Tab completion is your friend! It helps prevent spelling mistakes, and speeds up the process of typing in the full command. We encourage you to use this when working on the command line. </p>"},{"location":"ch01/02_week1_mmg3320/#relative-paths","title":"Relative paths","text":"<p>We have talked about full paths so far, but there are other ways to specify paths to folders and files without having to worry about the root directory. </p> <p>Let's create a folder in raw_fastq using the <code>mkdir</code> command. </p> <pre><code>syntax: `mkdir  name-of-folder-to-be-created`\n</code></pre> <pre><code>mkdir data\n</code></pre> <p>Now let's navigate back into <code>unit1_unix</code> </p>"},{"location":"ch01/02_week1_mmg3320/#class-exercise_2","title":"Class Exercise:","text":"<ul> <li>Change directories from <code>unit1_unix</code> to <code>data</code> in a single step. </li> </ul> <p> Answer <p>cd raw_fastq/data/</p> </p> <p>In this case we are using a relative path, relative to our current location - wherein we know that the <code>raw_fastq</code> folder is within <code>unit1_unix</code> and <code>data</code> is within the <code>raw_fastq</code> folder. </p>"},{"location":"ch01/02_week1_mmg3320/#synopsis-of-full-versus-relative-paths","title":"Synopsis of Full versus Relative paths","text":"<p>A full path always starts with a <code>/</code>, a relative path does not.</p> <p>A relative path is like getting directions from someone on the street. They tell you to \"go right at the Stop sign, and then turn left on Main Street\". That works great if you're standing there together, but not so well if you're trying to tell someone how to get there from another country. A full path is like GPS coordinates. It tells you exactly where something is no matter where you are right now.</p> <p>You can usually use either a full path or a relative path depending on what is most convenient. If we are in the home directory, it is more convenient to just enter the relative path since it involves less typing. However, when using some programs, full paths are required. </p> <p> </p>"},{"location":"ch01/02_week1_mmg3320/#example-using-full-paths","title":"Example using Full Paths:","text":"<p>It can get really complex, real fast!  </p> <pre><code>samtools merge WT_Ikaros_rep2_merged.bam \n/gpfs2/scratch/jrboyd/pipelines/cutruntools/output_mm10_cutnrun_bcell_stim_032621/aligned.aug10/sorted/WTU_Ikaros_H100_rep1_2_S23_L002_aligned_reads.bam \n/users/p/d/pdrodrig/cutnrun_bcell/unmerged_bams/WT_H100_IK_rep1.IK2_S2_L001_aligned_reads.bam;\n</code></pre> <p>Lets break this down! </p> <ul> <li>Program + argument = samtools merge  </li> <li>New file to be created = merge WT_Ikaros_rep2_merged.bam </li> <li>1st file = WTU_Ikaros_H100_rep1_2_S23_L002_aligned_reads.bam</li> <li>2nd file = WT_H100_IK_rep1.IK2_S2_L001_aligned_reads.bam</li> </ul> <p>Over time, it will become easier for you to keep a mental note of the structure of the directories that you are using and how to quickly navigate among them.</p>"},{"location":"ch01/02_week1_mmg3320/#copying-creating-moving-and-removing-data","title":"Copying, creating, moving and removing data","text":"<p>Now we can move around within the directory structure using the command line. But what if we want to do things like copy files or move them from one directory to another, or rename them? </p> <p>Let's move into the <code>raw_fastq</code> directory, this contains some fastq files which are the output of sequencing. </p> <pre><code>cd ~/unit1_unix/raw_fastq\n</code></pre> <p>Tip - These files are referred to as \"raw\" data since it has not been changed or analyzed after being generated.</p>"},{"location":"ch01/02_week1_mmg3320/#copying","title":"Copying","text":"<p>Let's use the copy (<code>cp</code>) command to make a copy of one of the files in this folder, <code>Mov10_oe_1.subset.fq</code>, and call the copied file <code>Mov10_oe_1.subset-copy.fq</code>.  The copy command has the following syntax: </p> <p><code>cp  path/to/item-being-copied  path/to/new-copied-item</code></p> <p>In this case the files are in our current directory, so we just have to specify the name of the file being copied, followed by whatever we want to call the newly copied file.</p> <pre><code>cp Mov10_oe_1.subset.fq Mov10_oe_1.subset-copy.fq\n\nls -l\n</code></pre> <p>The copy command can also be used for copying over whole directories, but the <code>-r</code> argument has to be added after the <code>cp</code> command. The <code>-r</code> stands for \"recursively copy everything from the directory and its sub-directories\". We used it earlier when we copied over the <code>unit1_unix</code> directory to our home directories.</p>"},{"location":"ch01/02_week1_mmg3320/#creating","title":"Creating","text":"<p>Next, let's create a directory called <code>fastq_backup</code> and we can move the copy of the fastq file into that directory. </p> <pre><code>mkdir fastq_backup\n</code></pre> <p>Tip - File/directory/program names with spaces in them do not work well in Unix, use characters like hyphens or underscores instead. Using underscores instead of spaces is called \"snake_case\". Alternatively, some people choose to skip spaces and rather just capitalize the first letter of each new word (i.e. MyNewFile). This alternative technique is called \"CamelCase\".</p>"},{"location":"ch01/02_week1_mmg3320/#moving","title":"Moving","text":"<p>We can now move our copied fastq file in to the new directory. We can move files around using the move command, <code>mv</code>, syntax: </p> <p><code>mv  path/to/item-being-moved  path/to/destination</code> </p> <p>In this case we can use relative paths and just type the name of the file and folder.</p> <pre><code>mv  Mov10_oe_1.subset-copy.fq  fastq_backup\n</code></pre> <p>Let's check if the move command worked like we wanted:</p> <pre><code>ls -l fastq_backup\n</code></pre>"},{"location":"ch01/02_week1_mmg3320/#renaming","title":"Renaming","text":"<p>The <code>mv</code> command has a second functionality. You can use <code>mv</code> to rename files too. The syntax is identical to when we used <code>mv</code> for moving, but this time instead of giving a directory as its destination, we just give a new name as its destination. </p> <p>Let's try out this functionality!</p> <p>The name Mov10_oe_1.subset-copy.fq is not very informative, we want to make sure that we have the word \"backup\" in it so we don't accidentally delete it.</p> <pre><code>cd fastq_backup\n\nmv  Mov10_oe_1.subset-copy.fq   Mov10_oe_1.subset-backup.fq\n\nls\n</code></pre> <p>Tip - You can use move to move a file and rename it at the same time!</p> <p>Important notes about <code>mv</code>: * When using <code>mv</code>, shell will not ask if you are sure that you want to \"replace existing file\" or similar unless you use the -i option.  * Once replaced, it is not possible to get the replaced file back!</p>"},{"location":"ch01/02_week1_mmg3320/#removing","title":"Removing","text":"<p>We found out that we did not need to create backups of our fastq files manually as backups were already generated by our collaborator. So in the interest of saving space on the cluster, we want to delete the contents of the <code>fastq-backup</code> folder and the folder itself. </p> <pre><code>rm  Mov10_oe_1.subset-backup.fq\n</code></pre> <p>Important notes about <code>rm</code> * <code>rm</code> permanently removes/deletes the file/folder.  * There is no concept of \"Trash\" or \"Recycle Bin\" on the command-line. When you use <code>rm</code> to remove/delete they're really gone.  * Be careful with this command! * You can use the <code>-i</code> argument if you want it to ask before removing, <code>rm -i file-name</code>.</p> <p>Let's delete the fastq_backup folder too. First, we'll have to navigate our way to the parent directory (we can't delete the folder we are currently in/using). </p> <pre><code>cd ..\n\nrm  fastq_backup \n</code></pre> <p>Did that work? Did you get an error?</p> Explanation <p>By default, <code>rm</code>, will NOT delete directories, but you use the <code>-r</code> flag if you are sure that you want to delete the directories and everything within them. To be safe, let's use it with the <code>-i</code> flag.</p> <p></p> <pre><code>rm -ri fastq_backup\n</code></pre> <ul> <li><code>-r</code>: recursive, commonly used as an option when working with directories, e.g. with <code>cp</code>. </li> <li><code>-i</code>: prompt before every removal.</li> </ul>"},{"location":"ch01/02_week1_mmg3320/#commands","title":"Commands","text":"<pre><code>cd          # Change Directory\n               +   used to move throughout the filesystem of a computer \n\nls          # List \n              +   list the contents of a directory\n\npwd         # Print Working Directory   \n              +  displays the file path from the root directory to the current working directory \n\ntree        # prints a tree of the file structure\n\ncp          # Copy\n              +   used to copy files or directories \n\nmkdir       # Make Directory\n              +   used to make a new directory \n\nmv          # Move \n              +   move a file into a directory \n\nrm          # Remove\n              +   used to delete files and directories \n</code></pre>"},{"location":"ch01/02_week1_mmg3320/#homework-assignment-1-50-points","title":"Homework Assignment #1 (50 points)","text":"<p>For this assignment you will have until 10AM on Tuesday, January 23rd to submit. Late assignments will not be accepted. </p>"},{"location":"ch01/02_week1_mmg3320/#directions-for-students","title":"Directions for Students:","text":"<p>Open a new Microsoft Word Document, the first four lines of your document should contain the following: + Your name + MMG3320/5320 + Today's date + Homework Assignment # 1</p>"},{"location":"ch01/02_week1_mmg3320/#task-1","title":"Task 1:","text":"<ul> <li>On Terminal, open the manual page for the <code>rm</code> command. Skim through the information. </li> </ul> <p>1)  What happens if you add the <code>-f</code> argument?  2)  Is there any argument available to \"undelete\" a file?   </p> <ul> <li>Quit the <code>man</code> buffer page and come back to your command prompt.  </li> </ul> <p>Tip - Shell commands can get extremely complicated. No one can possibly learn all of these arguments, of course. So you will probably find yourself referring to the manual page frequently.</p> <p>Tip - If the manual page within the Terminal is hard to read , the manual exists online too. For example, here is the linux manual page for <code>cp</code>. https://man7.org/linux/man-pages/man1/cp.1.html In addition to the arguments, you can also find good examples online; Google is your friend.</p>"},{"location":"ch01/02_week1_mmg3320/#task-2","title":"Task 2:","text":"<ul> <li>Use the <code>-lh</code> option for the <code>ls</code> command to display more information for each item in the <code>unit1_unix</code> folder. </li> </ul> <p>3) Submit a screenshot of your terminal screen and underneath describe what additional information is provided that you didn't see with the bare <code>ls</code> command. </p> <p>For #4-6, submit a screenshot of your terminal screen. Be sure to clear your terminal screen using control + L before proceeding </p> <p>4) Create a new folder in <code>unit1_unix</code> called <code>selected_fastq</code> 5) Copy over the Irrel_kd_2.subset.fq and Mov10_oe_2.subset.fq from <code>raw_fastq</code> to the <code>selected_fastq</code> folder 6) Rename the <code>selected_fastq</code> folder and call it <code>exercise1</code> </p>"},{"location":"ch01/02_week1_mmg3320/#citation","title":"Citation","text":"<p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> <ul> <li>The materials used in this lesson were derived from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).  All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</li> <li>Adapted from the lesson by Tracy Teal. Original contributors: Paul Wilson, Milad Fatenejad, Sasha Wood and Radhika Khetani for Software Carpentry (http://software-carpentry.org/) authors: Sheldon  McKay, Mary Piper, Radhika Khetani, Meeta Mistry, Jihe Liu date posted: September 28, 2020</li> </ul> <p>Other parts of this lesson were derived from: Erin Alison Becker, Anita Sch\u00fcrch, Tracy Teal, Sheldon John McKay, Jessica Elizabeth Mizzi,  Fran\u00e7ois Michonneau, et al. (2019, June). datacarpentry/shell-genomics: Data Carpentry: Introduction to the shell for genomics data,  June 2019 (Version v2019.06.1). Zenodo. http://doi.org/10.5281/zenodo.3260560</p>"},{"location":"ch02/","title":"Overview","text":""},{"location":"ch02/#chapter-2","title":"Chapter 2","text":"<p>Chapter the second.</p>"},{"location":"ch02/03_week2_mmg3320/","title":"Learning Objectives","text":"<ul> <li>Implement tab completion when writing paths</li> <li>Use of the asterisk <code>*</code> wildcard to select multiple items</li> <li>List a few shortcuts </li> <li>View the contents of a file</li> </ul>"},{"location":"ch02/03_week2_mmg3320/#recap-from-last-week","title":"Recap from last week","text":""},{"location":"ch02/03_week2_mmg3320/#commands","title":"Commands","text":"<pre><code>cd          # Change Directory\n               +   used to move throughout the filesystem of a computer \n\nls          # List \n              +   list the contents of a directory\n\npwd         # Print Working Directory   \n              +  displays the file path from the root directory to the current working directory \n\ncp          # Copy\n              +   used to copy files or directories \n\nmkdir       # Make Directory\n              +   used to make a new directory \n\nmv          # Move \n              +   move a file into a directory \n\nrm          # Remove\n              +   used to delete files and directories \n</code></pre>"},{"location":"ch02/03_week2_mmg3320/#home-directory-or","title":"Home directory or \"~\"","text":"<p>Dealing with the home directory is very common. In shell, the tilde character \"~\" is a shortcut for your home directory. Let's navigate to the <code>raw_fastq</code> directory: </p> <p>Then enter the command:</p> <pre><code>cd ~\n</code></pre> <p>This allows you to easily navigate to your home directory. The tilde \"~\" is equivalent to \"/gpfs1/home/p/d/pdrodrig\" as we had mentioned in the previous lesson.</p>"},{"location":"ch02/03_week2_mmg3320/#parent-directory-or","title":"Parent directory or \"..\"","text":"<p>Another shortcut you encountered in the previous lesson is \"..\"</p> <pre><code>cd ..\n</code></pre> <p>The shortcut <code>..</code> always refers to the parent directory of whatever directory you are in currently. Let navigate to <code>reference_data</code> to test <code>..</code> once again. </p> <p>We can also chain <code>..</code> together and separate them by <code>/</code> to navigate to two directories above. </p> <pre><code>cd ../..\n</code></pre>"},{"location":"ch02/03_week2_mmg3320/#current-directory-or","title":"Current directory or \".\"","text":"<p>Finally, <code>.</code> always refers to your current directory. Recall that we use <code>.</code> a number of times, when copying data to your home directory.</p> <p>Class Activity #1</p> <p>Before moving on, please complete the following class activity below. You will have ~5 minutes. </p> <p>Class-activity1</p>"},{"location":"ch02/03_week2_mmg3320/#saving-time-with-wildcards-and-other-shortcuts","title":"Saving time with wildcards and other shortcuts","text":"<p>Remember to use tab completion! </p>"},{"location":"ch02/03_week2_mmg3320/#wild-cards","title":"Wild cards","text":"<p>The \"*\" wildcard:</p> <p>Navigate to the <code>~/unit1_unix/raw_fastq</code> directory. This directory contains FASTQ files and these files contain the sequencing reads (nucleotide sequences) output from a high throughput sequencer. </p> <p> </p> <p>Let's see what is inside:  </p> <p><pre><code>ls\n</code></pre> <pre><code>Irrel_kd_1.subset.fq    Irrel_kd_3.subset.fq    Mov10_oe_2.subset.fq\nIrrel_kd_2.subset.fq    Mov10_oe_1.subset.fq    Mov10_oe_3.subset.fq\n</code></pre></p> <p>Let's take a moment to point a few things out:  + .fq vs .fastq  + .gz </p> <p>.gz is a file format used for compressed files. This is especially important when dealing with large data.  /gpfs1/home/p/d/pdrodrig/class_data/GSE164713_Tcf1/ChIPseq </p> <p>Class Activity #2 </p> <p>Create a directory within <code>raw_fastq</code> and call it fastq and another file called data. Then list the contents.  Your output should look like below: </p> <pre><code>data   Irrel_kd_1.subset.fq  Irrel_kd_3.subset.fq  Mov10_oe_2.subset.fq\nfastq  Irrel_kd_2.subset.fq  Mov10_oe_1.subset.fq  Mov10_oe_3.subset.fq\n</code></pre> <p>The \"*\" or wildcard character is a shortcut for \"everything\". You can use it by typing in shift + 8.  Now try this command:</p> <pre><code>ls *.fq\n</code></pre> <p>Notice, this lists every file that ends with a <code>fq</code> and our newly made directory fastq is missing. </p> <pre><code>Irrel_kd_1.subset.fq    Irrel_kd_3.subset.fq    Mov10_oe_2.subset.fq\nIrrel_kd_2.subset.fq    Mov10_oe_1.subset.fq    Mov10_oe_3.subset.fq\n</code></pre> <p>Class Activity #3 </p> <p>Remove the newly created folders fastq and data. </p> <p>Now try a more complicated command to list every file in <code>/usr/bin</code> directory that ends in the characters <code>.sh</code>. The <code>bin</code> directory is where some built-in programs are stored. </p> <pre><code>ls /usr/bin/*.sh\n</code></pre> <pre><code>/usr/bin/gettext.sh  /usr/bin/lesspipe.sh  /usr/bin/rescan-scsi-bus.sh   /usr/bin/unix-lpr.sh\n/usr/bin/gvmap.sh    /usr/bin/lprsetup.sh  /usr/bin/setup-nsssysinit.sh\n</code></pre> <p>Let's quickly try it without <code>*.sh</code> - notice that you have so many more options! </p>"},{"location":"ch02/03_week2_mmg3320/#command-history","title":"Command History","text":"<p>You can easily access previous commands by hitting the up arrow key on your keyboard, this way you can step backwards through your command history. On the other hand, the down arrow key takes you forward in the command history.</p> <p>Try it out! While on the command prompt hit the up arrow a few times, and then hit the down arrow a few times until you are back to where you started.</p> <p>You can also review your recent commands with the <code>history</code> command. Just enter:</p> <pre><code>$ history\n</code></pre> <p>You should see a numbered list of commands, including the <code>history</code> command you just ran! </p> <p>NOTE: So far we have only run very short commands that have very few or no arguments. It would be faster to just retype it than to check the history. However, as you start to run analyses on the command-line you will find that the commands are longer and more complex, and the <code>history</code> command will be very useful then!</p> <p>The wildcard \"*\" can be placed anywhere in your pattern. For example:</p> <pre><code>ls Mov10*fq\n</code></pre> <p>This lists only the files that begin with 'Mov10' and end with <code>fq</code>.</p> <pre><code>Mov10_oe_1.subset.fq  Mov10_oe_2.subset.fq  Mov10_oe_3.subset.fq\n</code></pre> <p>So how does this actually work? The Shell (bash) considers an asterisk * to be a wildcard character that can match one or more occurrences of any character, including no character. In the example above the * took place of 13 characters! </p> <p>Tip - An asterisk/star is only one of the many wildcards in Unix, but this is the most powerful one and we will be using this one the most for our exercises.</p> <p>The \"?\" wildcard:</p> <p>Another wildcard that is sometimes helpful is <code>?</code>  + <code>?</code> is similar to <code>*</code> except that it is a placeholder for exactly one position.  + Recall that <code>*</code> can represent any number of following positions, including no positions.  + To highlight this distinction lets look at a few examples. First, try this command:</p> <p><code>ls /bin/d*</code></p> <p>This will display all files in <code>/bin/</code> that start with \"d\" regardless of length. However, if you only wanted the things in <code>/bin/</code> that start with \"d\" and are two characters long then you can use:</p> <p><code>ls /bin/d?</code></p> <p>Lastly, you can chain together multiple \"?\" marks to help specify a length. In the example below, you would be looking for all things in <code>/bin/</code> that start with a \"d\" and have a name length of three characters.  </p> <p><code>ls /bin/d??</code> </p> <p>Class Activity #4 </p> <p>Perform each of the following tasks using a single <code>ls</code> command without navigating to a different directory.</p> <ol> <li> <p>List all of the files in <code>/bin</code> that start with the letter 'c'</p> </li> <li> <p>List all of the files in <code>/bin</code> that contain the letter 'a'</p> </li> <li> <p>List all of the files in <code>/bin</code> that end with the letter 'o'</p> </li> <li> <p>BONUS: List all of the files in <code>/bin</code> that start with 'ch' and are only 5 letters in length. </p> <p> Answers <p>Click each question below to reveal the answer.</p> Question 1 <code>ls /bin/c Question 2 <code>ls /bin/a Question 3 <code>ls /bin/o</code> BONUS <code>ls /bin/ch???</code>"},{"location":"ch02/03_week2_mmg3320/#cancel-a-command","title":"Cancel a command","text":"<p>Sometimes as you enter a command, you realize that you don't want to continue or run the current line. Instead of deleting everything you have entered (which could be very long), you could quickly cancel the current line and start a fresh prompt with Ctrl + C.</p> <pre><code>cd /users/p/d/pdrodrig/class_data/GSE164713_Tcf1/ChIPseq\nfastqc SRR13416485_1.fastq.gz\n</code></pre> <pre><code>Started analysis of SRR13416485_1.fastq.gz\nApprox 5% complete for SRR13416485_1.fastq.gz\n</code></pre> <p>then I hit Ctrl + C</p>"},{"location":"ch02/03_week2_mmg3320/#examining-files","title":"Examining Files","text":"<p>Now let's explore a few more commands to examine files. </p>"},{"location":"ch02/03_week2_mmg3320/#cat-command","title":"<code>cat</code> command","text":"<p>The easiest way to examine a file is to print out all of its contents using the command <code>cat</code>. We can test this out by printing the contents of <code>~/unit1_unix/other/sequences.fa</code></p> <pre><code>cat sequences.fa\n</code></pre> <p>The <code>cat</code> command prints out the all the contents of <code>sequences.fa</code> to the screen.</p> <p><code>cat</code> stands for catenate; it has many uses and printing the contents of a files onto the terminal is one of them.</p> <p>What does this file contain?</p> <pre><code>&gt;SRR014849.1 EIXKN4201CFU84 length=93 \nGGGGGGGGGGGGGGGGCTTTTTTTGTTTGGAACCGAAAGGGTTTTGAATTTCAAACCCTTTTCGGTTTCCAACCTTCCAAAGCAATGCCAATA\n\n&gt;gi|340780744|ref|NC_015850.1| Acidithiobacillus caldus SM-1 chromosome, complete genome\nATGAGTAGTCATTCAGCGCCGACAGCGTTGCAAGATGGAGCCGCGCTGTGGTCCGCCCTATGCGTCCAACTGGAGCTCGTCACGAG\nTCCGCAGCAGTTCAATACCTGGCTGCGGCCCCTGCGTGGCGAATTGCAGGGTCATGAGCTGCGCCTGCTCGCCCCCAATCCCTTCG\nTCCGCGACTGGGTGCGTGAACGCATGGCCGAACTCGTCAAGGAACAGCTGCAGCGGATCGCTCCGGGTTTTGAGCTGGTCTTCGCT\nCTGGACGAAGAGGCAGCAGCGGCGACATCGGCACCGACCGCGAGCATTGCGCCCGAGCGCAGCAGCGCACCCGGTGGTCACCGCCT\nCAACCCAGCCTTCAACTTCCAGTCCTACGTCGAAGGGAAGTCCAATCAGCTCGCCCTGGCGGCAGCCCGCCAGGTTGCCCAGCATC\nCAGGCAAATCCTACAACCCACTGTACATTTATGGTGGTGTGGGCCTCGGCAAGACGCACCTCATGCAGGCCGTGGGCAACGATATC\nCTGCAGCGGCAACCCGAGGCCAAGGTGCTCTATATCAGCTCCGAAGGCTTCATCATGGATATGGTGCGCTCGCTGCAACACAATAC\nCATCAACGACTTCAAACAGCGTTATCGCAAGCTGGACGCCCTGCTCATCGACGACATCCAGTTCTTTGCGGGCAAGGACCGCACCC\n\n&gt;gi|129295|sp|P01013|OVAX_CHICK GENE X PROTEIN (OVALBUMIN-RELATED)\nQIKDLLVSSSTDLDTTLVLVNAIYFKGMWKTAFNAEDTREMPFHVTKQESKPVQMMCMNNSFNVATLPAE\n</code></pre> <p>This is a FASTA file. FASTA format is a text-based format for representing either nucleotide or peptide sequences. The structure of a FASTA file is represented below where the header row always begins with the \"&gt;\" symbol. </p> <p> </p> <p>Question: What command would I use to clear my terminal screen? </p> Answer <p>Ctrl + L </p>"},{"location":"ch02/03_week2_mmg3320/#less-command","title":"<code>less</code> command","text":"<p><code>cat</code> is a terrific command, but notice what it is doing. It is PRINTING the file contents on the screen. </p> <p>When the file is really big and has a ton of lines, this can be cumbersome to use. In practice, when you are running your analyses on the command-line you will most likely be dealing with large files so you need to learn how to view them. </p> <p>Instead, we will use the <code>less</code> command </p> <p><pre><code>less Mov10_oe_1.subset.fq\n</code></pre> Rather than printing to screen, the <code>less</code> command opens the file in a new buffer allowing you to navigate through it. Does this look familiar? You might remember encountering a similar interface when you used the <code>man</code> command. This is because <code>man</code> is using the <code>less</code> command to open up the documentation files! The keys used to move around the file are identical to the <code>man</code> command. Below we have listed some additional shortcut keys for navigating through your file when using <code>less</code>.</p> <p>Shortcuts for <code>less</code></p> key action SPACE to go forward b to go backwards g to go to the beginning of the file G to go to the end of a file q to quit or exit <code>less</code> <p>Use the shortcut keys to move through your FASTQ file, we will explore these files in more detail later in the workshop. </p>"},{"location":"ch02/03_week2_mmg3320/#searching-files-with-less","title":"Searching files with <code>less</code>","text":"<p><code>less</code> also gives you a way of searching through files. </p> <p>Just type in / to begin a search, you will see that the <code>/</code> will show up at the  bottom of the <code>less</code> buffer. Let's say you are interested in searching for the following 8-letter adapter sequence: </p> <pre><code>/GGCGAATT\n</code></pre> <p>Enter the name of the string of characters you would like to search for and hit the enter key. The interface will move to show you the location where that string is found, and highlight the string. </p> <p>If you hit / then ENTER, <code>less</code> will just repeat the previous search. </p> <p><code>less</code> searches from the current location and works its way forward. For instance, the sequence <code>GGCGAATT</code> was found in our file, but if we started the search at the end of the file, <code>less</code> will not find it. You need to go to the beginning of the file and search.</p> <p>To exit hit q. </p>"},{"location":"ch02/03_week2_mmg3320/#head-and-tail-commands","title":"<code>head</code> and <code>tail</code> commands","text":"<p>There is another way that we can peek inside files. In particular, if we just want to see the beginning or end of the file to see how it's formatted.</p> <p>The commands are <code>head</code> and <code>tail</code> and they just let you look at the beginning and end of a file respectively.</p> <pre><code>head Mov10_oe_1.subset.fq\n</code></pre> <pre><code>tail Mov10_oe_1.subset.fq\n</code></pre> <p>By default, the first or last 10 lines will be printed to screen. The <code>-n</code> option can be used with either of these commands to specify the number <code>n</code> lines of a file to display. For example, let's print the first/last line of the file:</p> <pre><code>head -n 20 Mov10_oe_1.subset.fq\n\ntail -n 20 Mov10_oe_1.subset.fq\n</code></pre>"},{"location":"ch02/03_week2_mmg3320/#summary-commands-options-and-keystrokes-covered","title":"Summary: Commands, options, and keystrokes covered","text":"<p>The wildcard * + can represent zero or more other characters + can be placed anywhere in your pattern</p> <pre><code>~           # home dir\n.           # current dir\n..          # parent dir\n*           # wildcard\nctrl + c    # cancel current command\nctrl + a    # start of line\nctrl + e    # end of line\nctrl + l    # clear your terminal screen\nhistory\ncat         # prints out the all the contents of file \nless        # allows you to view and move through file content \nhead        # allows you to view beginning of file \ntail        # allows you to view end of file \n</code></pre>"},{"location":"ch02/03_week2_mmg3320/#homework-assignment-2-50-points","title":"Homework Assignment #2 (50 points)","text":"<p>This \"mini\" assignment is due on Tuesday, January 30th anytime before class start. Late assignments will not be accepted. </p>"},{"location":"ch02/03_week2_mmg3320/#directions-for-students","title":"Directions for Students:","text":"<p>Open a new Microsoft Word Document and submit answers to the questions below. The first four lines of your document should contain the following: + Your name + MMG3320/5320 + Today's date + Homework Assignment #2</p> <ol> <li> <p>Type <code>ls'</code> then type <code>history</code> then hit return</p> <p>The output should look something like this: </p> <pre><code>$ ls' \n&gt;history\n&gt;\n</code></pre> <p>Oh no! How would you escape this so you are able to move on to Question 2?  Submit a screenshot of your terminal screen.</p> </li> <li> <p>This is a multi-part question:      a. Change directories into <code>genomics_data</code>. You can do this using a full or relative path.     b. Use the <code>less</code> command to open up the file <code>Encode-hesc-Nanog.bed</code>.     c. Search for the string <code>chr11</code>; you'll see all instances in the file highlighted.     d. Staying in the <code>less</code> buffer, use the shortcut to get to the end of the file.        &gt; Report three rows starting with <code>chr11</code>.   Exit the <code>less</code> buffer and come back to the command prompt.  </p> </li> <li> <p>Print to screen the last 5 lines of the file <code>Encode-hesc-Nanog.bed</code>. Submit a screenshot of the output of Terminal.</p> </li> <li> <p>How many commands have you typed after going through this exercise? Submit a screenshot of the output of Terminal.</p> </li> </ol>"},{"location":"ch02/03_week2_mmg3320/#citation","title":"Citation","text":"<p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> <ul> <li>The materials used in this lesson were derived from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).  All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0).</li> <li>Adapted from the lesson by Tracy Teal. Original contributors: Paul Wilson, Milad Fatenejad, Sasha Wood and Radhika Khetani for Software Carpentry (http://software-carpentry.org/) </li> <li>Other Authors include: Sheldon  McKay, Mary Piper, Radhika Khetani, Meeta Mistry, Jihe Liu, Mary Piper, Meeta Mistry, Jihe Liu, &amp; Will Gammerdinger</li> </ul>"},{"location":"ch02/04_week3_mmg3320/","title":"Learning Objectives","text":"<ul> <li>Use nano and/or vim to create and edit files </li> </ul>"},{"location":"ch02/04_week3_mmg3320/#recap-from-last-week-working-with-files","title":"Recap from last week: Working with files","text":"<pre><code>~           # home dir\n.           # current dir\n..          # parent dir\n*           # wildcard\nctrl + c    # cancel current command\nctrl + l    # clear your terminal screen\ncat         # prints out the all the contents of file \nless        # allows you to view and move through file content \nhead        # allows you to view beginning of file \ntail        # allows you to view end of file \n</code></pre> <p>The wildcard * + can represent zero or more other characters + can be placed anywhere in your pattern</p>"},{"location":"ch02/04_week3_mmg3320/#good-names-for-files-and-directories","title":"Good names for files and directories","text":"<p>Complicated names of files and directories can make your life painful when working on the command line. Here we provide a few useful tips for the names of your files and directories.</p> <pre><code>Don\u2019t use spaces.\n</code></pre> <p>Spaces can make a name more meaningful, but since spaces are used to separate arguments on the command line it is better to avoid them in names of files and directories. You can use - or _ instead (e.g. fastq-data-files/ rather than fastq data files/). To test this out, try typing mkdir fastq data files and see what directory (or directories!) are made when you check with ls -F.</p> <pre><code>Don\u2019t begin the name with - (dash).\n\nDon\u2019t begin the name with numbers.\n\nStick with letters in the beginning and then use numbers, . (period), - (dash), or an _ (underscore) in the middle of the file or directory name.\n</code></pre> <p>You may have noticed by now that all the files we are using are named \u2018something dot something\u2019.  + This is just a convention; we can call a file mythesis or almost anything else we want. However, most people use two-part names most of the time to help them (and their programs) tell different kinds of files apart. </p> <p> </p> <ul> <li>The second part of such a name is called the filename extension and indicates what type of data the file holds: .txt signals a plain text file, .pdf indicates a PDF document, .cfg is a configuration file full of parameters for some program or other, .png is a PNG image, and so on.</li> <li>This is just a convention, albeit an important one. Files merely contain bytes; it\u2019s up to us and our programs to interpret those bytes according to the rules for plain text files, PDF documents, configuration files, images, and so on.</li> <li>However, naming a PNG image of a whale as whale.mp3 doesn\u2019t somehow magically turn it into a recording of whale song, though it might cause the operating system to associate the file with a music player program. In this case, if someone double-clicked whale.mp3 in a file explorer program,the music player will automatically (and erroneously) attempt to open the whale.mp3 file.</li> </ul> <p> </p> <p>Class Activity</p> <p>Before moving on, please complete the following class activity below. You will have ~5 minutes to answer all questions except the final one!  + Open the quiz in a separate screen and keep it open.  + We will return to this screen at a later time. </p> <p>Class-activity</p>"},{"location":"ch02/04_week3_mmg3320/#writing-files","title":"Writing files","text":"<p>We've been able to do a lot of work with files that already exist, but what if we want to create our own files? </p> <p>In order to create or edit files we will need to use a text editor. When we say, \"text editor,\" we really do mean \"text\". These editors can only work with plain character data, not tables, images, or any other media. Text editors can generally be grouped into two categories:  command-line editors and graphical user interface editors. </p>"},{"location":"ch02/04_week3_mmg3320/#command-line-editors","title":"Command-line editors","text":"<p>Some popular editors include: + Emacs + Vim + Gedit </p> <p>These are editors which are generally available for use on high-performance compute clusters. There are also simpler editors available for use on the cluster (e.g. Nano), but tend to have limited functionality. We will discuss Nano and Vim in this lesson. </p>"},{"location":"ch02/04_week3_mmg3320/#which-editor-to-use","title":"Which editor to use?","text":""},{"location":"ch02/04_week3_mmg3320/#nano","title":"Nano","text":"<p>Nano is a simple text editor for UNIX/Linux operating systems. Nano is easy-to-use but has its' limitations. </p>"},{"location":"ch02/04_week3_mmg3320/#creating-or-editing-a-file","title":"Creating or editing a file","text":"<p>To create a new file or edit an existing one type: </p> <pre><code>nano filename\n</code></pre> <p>Type the following in your terminal: </p> <pre><code>nano colors.txt\n</code></pre> <p>After pressing the Enter key, the nano editor appears. Notice the following elements:  + the top line displays the version of nano in the left corner and the name of the file being edited  + the 3rd line from the bottom indicates the status of the file you're editing; it shows that color.txt is a \"New File\"  + the last two lines of the screen present a menu of useful shortcuts for nano. They all will require you to use the control button on your laptop. </p> <p> </p> <p>At this point we can begin typing:  <pre><code>red\nblue \nyellow\n</code></pre></p> <p>Notice that after your first keystroke, the word \"Modified appears in the upper-right corner. This shows that you have changed the contents of your file but it has not been saved yet. </p> <p> </p> <ul> <li> <p>Saving your work: To save your edited file to disk, press Ctrl-o. Nano displays the current filename. (To save the file under a different name, delete the filename that Nano displays and type a new one.) Press Enter. </p> </li> <li> <p>Exiting Nano:  To exit Nano, press control + x. If you made any changes since the last save, Nano will ask whether or not to save them. Type <code>y</code> for yes or <code>n</code> for no. Press Enter. </p> </li> </ul> <p> </p> <p>Class activity #2  You will have ~5 minutes to complete</p> <ol> <li>Grab <code>get-pip.py</code> from this location /gpfs1/cl/mmg3320/course_materials/tutorials</li> <li>Open <code>get-pip.py</code></li> <li>Copy and paste the 5th line as the answer for the final quiz question</li> <li>Exit and return to terminal </li> </ol>"},{"location":"ch02/04_week3_mmg3320/#summary-basic-nano-commands","title":"Summary Basic nano commands","text":"key action control + X exit from the editor control + A Let's you jump from the beginning of the line control + E Let's you jump from the end of the line control + V Scroll page down control + Y Scroll page up control + O Save the file control + K It cuts the entire selected line"},{"location":"ch02/04_week3_mmg3320/#introduction-to-vim","title":"Introduction to Vim","text":"<p>Vim is another text editor, but it is much more powerful than Nano because it offers extensive text editing options. We will explore some of the differences. </p>"},{"location":"ch02/04_week3_mmg3320/#how-do-i-keep-track-of-all-these-shortcuts-in-vim","title":"How do I keep track of all these shortcuts in Vim?","text":"<p>To help you remember some of the keyboard shortcuts that are introduced and to allow you to explore additional functionality on your own, hbctraining has already compiled a cheatsheet linked here. Download it to your computer, it is a useful resource to have open while using Vim. <p> </p></p>"},{"location":"ch02/04_week3_mmg3320/#vim-interface","title":"Vim Interface","text":"<p>You can create a document by calling a text editor (in our case <code>vim</code>) and providing the name of the document you wish to create. </p> <p>Change directories to the <code>unix_lesson/other</code> and create a document using called <code>draft.txt</code> using the <code>vim</code> command:</p> <pre><code>vim draft.txt\n</code></pre> <p> </p> <p>Notice the <code>\"draft.txt\" [New File]</code> typed at the bottom left-hand section of the screen. This tells you that you just created a new file in vim. </p>"},{"location":"ch02/04_week3_mmg3320/#vim-modes","title":"Vim Modes","text":"<p>Vim has two basic modes that will allow you to create documents and edit your text:   </p> <ul> <li> <p>command mode (default mode): will allow you to save and quit the program (and execute other more advanced commands).  </p> </li> <li> <p>insert (or edit) mode: will allow you to write and edit text</p> </li> </ul> <p>Upon creation of a file, vim is automatically in command mode. Let's change to insert mode by typing i. Note the <code>--INSERT--</code> at the bottom left hand of the screen. </p> <p>Now type in a few lines of text:</p> <p> </p> <p>After you have finished typing, press esc to enter command mode. </p> <p>Note the <code>--INSERT--</code> has now disappeared from the bottom of the screen.</p>"},{"location":"ch02/04_week3_mmg3320/#review-of-vim-modes","title":"Review of Vim modes","text":"key action i insert mode - to write and edit text esc command mode - to issue commands / shortcuts"},{"location":"ch02/04_week3_mmg3320/#saving-and-quitting","title":"Saving and Quitting","text":"<p>To \"write to file\" or save the modifications made to the file, type :w when in command mode. You can see the commands you type in the bottom left-hand corner of the screen. </p> <p> </p> <p>After you have saved the file, the total number of lines and characters in the file will print out at the bottom left-hand section of the screen.</p> <p> </p> <p>Alternatively, we can write to file (save changes) and quit all at once by typing :wq. After typing :wq while on command mode, you will exist vim and be returned back to your command prompt.</p> <p>Class activity #3  You will have ~5 minutes to complete</p> <ol> <li>Create a new file called <code>spider.txt</code> using <code>vim</code>. </li> <li>Go into insert mode and enter the text as shown below in the screenshot: </li> </ol> <p> </p> <p>Once you have finished typing, you can display line numbers by changing to command mode and then typing the :set number command. Later, if you choose to remove the line numbers you can reset it with :set nonumber.</p> <p> </p> key (in command mode) action :set number to number lines :set nonumber to remove line numbers <p>Save the document using :w </p> <p>Now while in command mode, try moving around the file <code>spider.txt</code> and familiarizing yourself with some of these shortcuts!  </p> <p>Navigating around the file</p> key (in command mode) action gg to move to top of file G to move to bottom of file $ to move to end of line 0 to move to beginning of line w to move to next word b to move to previous word <p>Practice some of the editing shortcuts, then quit the document and remember to save changes.</p> <p>Editing the file</p> key (in command mode) action dw to delete word dd to delete line u to undo Ctrl + r to redo /pattern to search for a pattern (n/N to move to next/previous match) :%s/search/replace/g to search for a pattern and replace for all occurrences <p>Class Exercise #4</p> <ol> <li>Open <code>spider.txt</code> and delete the word \"water\" from line #2. Note, you will need to be at the first letter of the word, to delete the entire word!</li> <li>Replace every occurrence of \"spider\" with \"unicorn\".</li> <li>Delete the line: \"Down came the rain.\" </li> <li>Delete the first word from each of the remaining lines.</li> <li>Save the file.</li> <li>Open the file and take a screenshot of your terminal screen. Submit this screenshot as homework Part A. </li> </ol>"},{"location":"ch02/04_week3_mmg3320/#review-of-saving-and-quitting","title":"Review of saving and quitting","text":"key (in command mode) action :w to write to file (save) :wq to write to file and quit :q! to quit without saving"},{"location":"ch02/04_week3_mmg3320/#gui-text-editors","title":"GUI text editors","text":"<p>A GUI is an interface that has buttons and menus that you can click on to issue commands to the computer and you can move about the interface just by pointing and clicking. These include BBEdit and Visual Studio Code, which allow you to write and edit plain text documents. These editors often have features to easily search text, extract text, and highlight syntax from multiple programming languages. They are great tools, and indeed you should download one to use to create your own scripts in the future! </p>"},{"location":"ch02/04_week3_mmg3320/#homework-assignment-3-50-points","title":"Homework Assignment #3 (50 points)","text":""},{"location":"ch02/04_week3_mmg3320/#please-note-that-you-will-have-until-next-class-thursday-february-1st-10am-to-submit-this-assignment-late-submissions-will-not-be-accepted","title":"Please note that you will have until next class (Thursday, February 1st - 10AM) to submit this assignment. Late submissions will not be accepted.","text":""},{"location":"ch02/04_week3_mmg3320/#directions-for-students","title":"Directions for Students:","text":"<p>Open a new Microsoft Word Document and submit two screenshot (Part A, B, and C). The first four lines of your document should contain the following: + Your name + MMG3320/5320 + Today's date + Homework Assignment #3</p> <p>Part A: Class Exercise #4 output. </p> <p>Part B: Generating your own script You got the following line of codes from a trusted source but need to modify it so you can submit it to the VACC-Bluemoon server. You decide its time to make your own script. Follow the steps below: </p> <ol> <li>Create a new file called <code>script.sh</code> in a text editor of your choice. </li> <li>The \".sh\" file extension typically indicates that a file is a shell script. </li> <li> <p>In Unix-like operating systems (such as Linux and macOS), shell scripts are plain text files containing a sequence of commands that can be executed by a shell.</p> </li> <li> <p>Paste in the code below to <code>script.sh</code>. </p> <pre><code>STAR --runThreadN 4 \\\n--runMode genomeGenerate \\\n--genomeDir /username/chr1_hg19_STAR_index/ \\\n--genomeFastaFiles /username/reference_data_ensembl/Homo_sapiens.GRCh19.dna.chromosome.1.fa \\\n--sjdbGTFfile /username/reference_data_ensembl/Homo_sapiens.GRCh19.gtf \n</code></pre> </li> <li> <p>Replace every occurrence of \"username\" with your home directory. </p> </li> <li>Delete the line containing --runMode</li> <li>Change the --runThreadN from 4 to 6  </li> <li>You would also like to use the newest genome assembly, human reference 38. Change this as well in your script. </li> <li>Save the file. </li> <li>Submit a screenshot of your final script as homework Part B. </li> </ol> <p>Please Take Note:  + The argument --genomeDir is pointing to an entire directory while --genomeFastaFiles is pointing to a specific file. This is really important as the program is looking for \"specific\" files or entire directories (with files in them!) to run successfully.  + Each line here ends with a <code>\\</code>. This is an escape character that signals that the character following it has a special meaning in this case its a continuation. </p> <p>Part C: Using \"vim\" one more time </p> <ol> <li>Grab <code>update_hg19_chromosomes.txt</code> from this location /gpfs1/cl/mmg3320/course_materials/tutorials</li> <li>Delete the final 5 lines of this document</li> <li>Replace every occurrence of \"sequence\" with \"peptide\" </li> <li>Report how many substitutions were created and how many lines were altered due to these changes as your final answer. Your answer should be one sentence. </li> </ol>"},{"location":"ch02/04_week3_mmg3320/#citation","title":"Citation","text":"<p>This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</p> <ul> <li>The materials used in this lesson were derived from work that is Copyright \u00a9 Data Carpentry (http://datacarpentry.org/).  All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0). </li> <li>Original Authors: Sheldon  McKay, Bob Freeman, Mary Piper, Radhika Khetani, Meeta Mistry, Jihe Liu, Will Gammerdinger</li> </ul>"}]}